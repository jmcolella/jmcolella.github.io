<!DOCTYPE html>
<head>
  <title>John Colella | Blog Post </title>
  <meta charset="UTF-8" name="viewport" content="width=device-width"/>
  <link href='https://fonts.googleapis.com/css?family=Ubuntu%7COxygen:400,700' rel='stylesheet' type='text/css'>
  <!-- <link type="text/css" rel="stylesheet" href="../stylesheets/default.css"> -->
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-post-template.css">
</head>

<body>

 <header class="head-container">
     <nav>
      <h1><a href="../index.html">John Colella</a></h1>
      <ul class="head-links">
        <li><a href="../index.html">Home</a></li>
        <li><a href="../index.html#about">About</a></li>
        <li><a href="..index.html#projects">Projects</a></li>
        <li><a href="../blog/index.html">Blog</a></li>
        <li><a href="../index.html#contact">Contact</a></li>
      </ul>
    </nav>
 </header>

 <nav class="post-nav font">
  <ul>
    <li><a href="JavaScript.html">Previous Post</a> | <a href="website-build.html">Next Post</a></li>
  </ul>
 </nav>

 <main>

    <section class="header font">
      <h2>DBC | Week 8 Post</h2>
      <h3>In which I discuss Regular Expressions in Ruby</h3>
      <h4>April 3, 2016</h4>
    </section>

    <section id="line"></section>

  <article class="font">
    <section class="text-over">
      <h3 class="strong">Introduction</h3>
      <p>
        As Phase 0 comes to a close for my DBC co-hort, this final blog post will be a surface exploration of a topic we haven't looked at closely over the past eight weeks. I've decided to stick within Ruby and dive into the concept of regular expressions. I had seen this topic come up a few times in David Black's <em>The Well-Grounded Rubyist</em>, but I had no idea what regular expressions were and wanted to use this opportunity to read more about them. From just my initial readings, I feel like this topic can become very complex very quickly, so this post will limit itself to the basic concepts and syntax of regular expressions in Ruby. For the last time in Phase 0, let's dive in...
      </p>
    </section>

    <section class="text-over">
      <h3 class="strong">Regular Expressions basics</h3>
      <p>
        In a nutshell, regular expressions (written as regexp or regex) are a matching tool. They can help a programmer parse through a string or file and return certain matched data based on specific parameters inside of the regular expression. We can use regular expressions to scan a string for occurrences of a pattern, to substitute a replacement string based on a pattern and to split a string into multiple substrings based on a matching separater. The key idea to take away is matching, which regular expressions can help us achieve.
      </p>
      <p>
        Pattern is also key to regular expressions. For every pattern in a regular expression, a string either matches that pattern or it doesn't, allowing a programmer to make use of this information either way. When we talk about a pattern in regards to regular expressions, we are talking about matching a particular arrangment of characters. In Ruby, one pattern could read as follows: "all numbers that begin with a letter." If we passed this to a string as a regular expression, the pattern we specificed would be returned if it found a match in the string, or it would not be returned if there was no match present. How exactly do we pass a pattern, or just one single chartacter, to a string as part of a regular expression?
      </p>
    </section>

    <section class="text-over">
      <h3 class="strong">Regular Expressions syntax</h3>
      <p>
        In Ruby, regular expressions look a lot like strings, however, they are not strings at all. Regular expressions are their own object completely in Ruby, that being the object regexp. On this granular level, it is clear that regexp and string are not the same.
      </p>
      <p>
        Visually, regular expressions are differentiated from strings in their specific syntax. That syntax is as follows:
      </p>
      <code class="indent-code">//</code>
      <p>
        Those forward slashes denote a regular expression, and anything written in between those slashes is a part of that regexp and, when called on a string, will be evaluated to find a match within that string. At the most basic level, we can try to find a match in a string of a single character. To do that, we have a nifty method to use called <code>match</code>.
      </p>
      <code class="indent-code">/a/.match("This is a string.")</code> <br>
      <code class="indent-code">=> #&#60;MatchData "a"&#62;</code>
      <p>
        In the above example, we called the <code>match</code> method on our regular expression <code>/a/</code> and passed a string as an argument. The <code>match</code> method then proceeds to find a match of the regular expression in the string argument. Since we do have a match, that match is returned as an instance of the <code>MatchData</code> class in Ruby. This is an important note because the <code>MatchData</code> class becomes useful when our regular expression patterns become more complex.
      </p>
      <p>
        If <code>match</code> did not find a match between the regexp and the string, then <code>nil</code> would have been returned. As you can see, regexp can be useful in a boolean type operator, where if there is a match, that evaluates to true, and if there isn't a match, that evaluates to <code>nil</code> aka false.
      </p>
      <p>
        As a last quick note in syntax, the <code>match</code> method can also be switched around and called on a string. Let's see that with our example above:
      </p>
      <code class="indent-code">"This is a string".match(/a/)</code> <br>
      <code class="indent-code">=> #&#60;MatchData "a"&#62;</code>
      <p>
        Our <code>MatchData</code> instance is still the same, but we switched up the order in which match evaluated the string and the regular expression. The big difference here is that, in our string version of <code>match</code>, the method converts the string to a regexp in order to evaluate it. No such conversion is necessary in our regexp version, since the object <code>match</code> is called on is already a regexp.
      </p>
    </section>

    <section class="text-over">
      <h3 class="strong">Advanced patterns in Regular Expressions</h3>
      <p>
        Regular expressions are pretty powerful because they can provide a lot of fine tuning in our ability to match very particular parts of a string. They can also help us store specific parts of a match as variables to use later in a program. The rabbit hole can get a bit deep, so for now we'll take a broad overview and introduce some syntax. You can always explore more on the internet or with David Black's book mentioned above.
      </p>
      <p>
        To build a more complex pattern, there are ways to write our regular expressions so we get the exact match we want. We can write regexp with special characters (like ?, ., /, [], (), etc.) as well write them to find a number of different matches that are similar but may deviate by one character or so. Let's look at this latter option, which provides to ways of doing this: dot wildcard notation and character classes.
      </p>
      <p>
        The dot wildcard allows a user to find a match of any character present in a string. Usually the dot is used in conjunction with other characters to find a specific pattern that may be written in different ways. The character classes are similar to the wildcard, but provide a more fine-tuned approach to the match; character classes will only provide a match for the various charactes your provide within its syntax. Let's take a look at both in tandem.
      </p>
      <p class="indent-code">Dot wildcard: <code>/.oon/.match("4oon")</code></p>
      <p class="indent-code">Character classes: <code>/[ns]oon/.match("Soon it will be noon.")</code></p>
      <p>
        For the dot wildard above, the match will be a success because the <code>.</code> will match <em>any</em> character; so, our string "4oon" matches the regexp <code>/.oon/</code>. Our character class, on the other hand, only provides a specific boundary for the match, designated by the bracket ([]) notation. In our example above, our regexp is telling match "success if the string contains any match of either 'noon' or 'soon'." The character class evaluates each one of its characters indepently with the rest of the regexp and finds a match based on that. In our case, we have two matches, with the wored "soon" and "noon".
      </p>
      <p>
        We can go even deeper with even more specific types of matching, like if we wanted to match a word that could either have a particular character, have none of that character, or have more than one of that character. This is an example of going down a bit too far down the rabbit hole, so we won't get into those types of patterns, but as our last bit of discussion, let's look briefly at capturing a match.
      </p>
    </section>

    <section class="text-over">
      <h3 class="strong">Captures in Regular Expressions</h3>
      <p>
        Say we have a string consisting of a person's full name, but we only want their first name, we can use the concept of captures to create a regexp that gives us our match in a useful, variable form. To do this, we simply use parantheses in our regexp to specify a capture. Let's look at an example below:
      </p>
      <code class="indent-code">name = "Lebowski, Jeffrey, D."</code> <br>
      <code class="indent-code">/(Jeffery)/.match(name)</code> <br>
      <code class="indent-code">=> #&#60;MatchData "Jeffrey"&#62;</code>
      <p>
        Alright, so we found a match in our <code>name</code> variable, but how do you know if this match was actually captured? By default, regexp catures are assigned to global Ruby variables. These global variables are simply numbers (<code>$1</code>, <code>$2</code> and so on) with each number representing the number capture from left to right. In our case, we only have one capture, that of "Jeffrey", so that match will be saved as global variable <code>$1</code>. If we had other captures after our first one, that is, captures to the right in our regexp, those captures would be labeled is increasing numbers from 1. Let's see below how we can make use of our newly caputed variable
      </p>
      <code class="indent-code">"Dear #{$1}"</code> <br>
      <code class="indent-code">=> "Dear Jeffrey"</code>
      <p>
        As you can see, this captured variable works like any other Ruby variable and it points to our capture from the regexp expression above. Now, this example was fairly hardwired. We can get even more complex by using more complicated patterns to grab any first name in any string that looks like our example variable <code>name</code>. This is the true power of regexp and demonstrates how one regexp can be applied to an infinite number of strings and the same type of match can be found.
      </p>
    </section>

    <section class="text-over">
        <h3 class="strong">Conclusion</h3>
        <p>
          At the onset, I said we'd stick with the basics, however, I think we went a bit deeper than that, which is OK. Regular expressions can become complex and I wanted to touch on a handful of ideas so you can see just how powerful they can be. The main take away, though, is that regular expressions are a tool for matching patterns in a string. This can be as simple as determinig if a match is true or as complex as saving a match as a variable to use in another regexp, which match will be caputred as a variable to be used in an output string. I'll leave it up to you to take the basic ideas in this post and explore further if you want to try out anything more complex.
        </p>
      </section>
    </article>
  </main>

  <nav class="post-nav font">
   <ul>
    <li><a href = "index.html">Blog index</a></li>
   </ul>
  </nav>

</body>
</html>