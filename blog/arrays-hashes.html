<!DOCTYPE html>
<head>
  <title>John Colella - Blog Post </title>
  <meta charset="UTF-8">
  <link href='https://fonts.googleapis.com/css?family=Ubuntu%7COxygen:400,700' rel='stylesheet' type='text/css'>
  <link type="text/css" rel="stylesheet" href="../stylesheets/default.css">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-post-template.css">
</head>

<body>

 <header class="center">
     <nav>
      <h1><a href="../new-index.html"><span class="upcase">J</span>ohn <span class="upcase">C</span>olella</a></h1>
      <ul class="nav">
        <li class="nav-reg"><a href="../new-index.html">Home</a></li>
        <li class="nav-reg"><a href="#">Resume</a></li>
        <li class="nav-reg"><a href="#">Projects</a></li>
        <li class="nav-reg"><a href="../blog/index.html">Blog</a></li>
        <li class="nav-reg"><a href="#">About</a></li>
        <li class="nav-reg"><a href="#">Contact</a></li>
      </ul>
    </nav>
 </header>

 <main>

    <section class="font text-over">
      <h2>Week 4 Blog Post</h2>
      <h3>In which I discuss arrays and hashes in Ruby</h3>
      <h4>February 28, 2016</h4>
     </section>

    <section id="line">
    </section>

  <article class="font">
    <section class="text-over">
      <h3 class="strong">Introduction</h3>
      <p>
        Welcome to the third post on my Dev Bootcamp blog! We've previously covered git/Github and the Box Model in CSS, and now we'll be moving on to some concepts in Ruby.
      </p>
      <p>
        This week, I'm going to explore the differences between arrays and hashes in Ruby. These two Ruby objects are incredibly versatile and can help you a ton when writing out a program. Let's dive in...
      </p>
    </section>

    <section class="text-over">
      <h3 class="strong">Arrays</h3>
      <p>
        Whereas variables in Ruby point to a specific value, arrays point to a list, or collection, of values. An array is still considered an object like a variable, but it can hold more data and, therefore, do some more powerful things.
      </p>
      <p>
        The array syntax is very simple. Let's take a look below at an array called <code>my_array</code>:
      </p>
      <code class="indent-code"> my_array = [1,2,3]</code>
      <p>
        OK great! We've got an array. But wait, you must be wondering, what exactly is going on here? Well, let's break it down. As I mentioned above, I created a new array called <code>my_array</code> and assigned it, using the <code>=</code> sign, to a list of values. I chose the values 1, 2 and 3 as arbitrary values. An array can hold more or less than 3 values, it can even hold no values at all! As you can see, just like we assign a variable to a value, we use the same type of syntax to assign an array to a list of values, the only major difference is wrapping the list of values with brackets.
      </p>
      <p>
        What's really cool about arrays is that, if we want, we could access an individual value within the array by simply calling its index. Whenver an array is created, it also comes along with index values, each of which points to a specific location within the array. Unlike in the real world, where we start counting from 1, in the world of Ruby, we start counting from zero. So, the first value in an array has an index number of 0. The second value has an index number of 1 and so on and so forth. As I mentioned above, an array can be set to an empty list, and in that case, if you called the 0 index, you will return the value <code>nil</code>.
      </p>
      <p>
        How would one go about calling an index in an array. Well, it's pretty simple. Let's take a look at the syntax below:
      </p>
      <code class="indent-code">my_array[1]</code>
      <code class="indent-code">=> 2</code>
      <p>
        So, I used our array from above <code>my_array</code> and called the index 1, returing the value of 2 from our example above. This is almost like passing an argument through a method; in this case, we are passing the index one to the array and it will spit back the value associated with that index. This can be incredibly helpful when trying to locate a particular value or when iterating over an array and you only want to execute code for a certain portion of the array (which can be denoted using the index number).
      </p>
    </section>

    <section class="text-over">
      <h3 class="strong">Hashes</h3>
      <p>
        The good thing is that hashes are incredibly similar to arrays in that they are an object that points to a list of values. The bad thing is that the syntax for hashes is completely different than for an array, however, we will see that maybe this way of storing values might be more beneficial for some complex programs.
      </p>
      <p>
        Let's take a look at the hash syntax and then break it down. Here's our newly minted hash, <code>my_hash</code>:
      </p>
      <code class="indent-code">my_hash = {</code>
      <code class="indent-code"> "Hello" => "Goodbye",</code>
      <code class="indent-code"> "First" => "Last",</code>
      <code class="indent-code">  "Big" => "Small",</code>
      <code class="indent-code"> } </code>
      <p>
        Alright, just like with an array, we are able to set <code>my_hash</code> equal to a list of values using the <code>=</code> operator. After that, things got a little cooky. So, let's look at the first line. We have "Hello" with some funny rocket-shaped synatx and then "Goodbye". First, let's tackle that funny syntax. That rocket-shaped thing is just a special way of saying equals; it's a special way to assign some value to something. Great, so now the syntax becomes a bit clearer: we have "Hello" equal to "Goodbye". How does Ruby know what each of these two strings are? Well, when you create a hash, Ruby knows that it will contain two major components: keys and values. Keys are set equal to a value and, vice vera, values are assigned to keys. In the hash syntax, the key always goes to the left of the <code>=></code> and the value always goes to the right. So, back to our first line in the hash, we created the key "Hello" and set it equal to "Goodbye". This can be applied to the other two rows: key "First" equals value "Last" and key "Big" equals value "Small".
      </p>
      <p>
        The key/value pair feature of hashes is a really powerful tool. In a way, it is very similar to the relationship between index and value in an array. Let's look at some syntax below regarding the cool relationship between keys and values:
      </p>
      <code class="indent-code">my_hash["Hello"]</code>
      <code class="indent-code">=> "Goodbye"</code>
      <p>
        Wow! Just like calling an index on an array and receiving the associated value, we can call a key on a hash and receive its associated value. This is very cool stuff and, as you could imagine, provides hashes with a lot more flexibility for a program than an array.
      </p>
    </section>

    <section class="text-over">
      <h3 class="strong">Arrays and Hashes compared</h3>
      <p>
        So, why might hashes have more flexibility than an array? For me, it depends on the program, but hashes can be much more powerful when you're working with user input.
      </p>
      <p>
        Let's look at a simple piece of code that takes a user's input regarding the tri-state area and returns a value:
      </p>
      <code class="indent-code">
        puts "Please enter the full name of a tri-state State and we'll give you the abbreviation!" </code>
        <code class="indent-code">user_input = gets.chomp.downcase </code>

        <code class="indent-code code-space">tri_state_abbr = { </code>
        <code class="indent-code">    "new york" => "NY" </code>
         <code class="indent-code">   "new jersey" => "NJ" </code>
         <code class="indent-code">   "connecticut" => "CT" </code>
        <code class="indent-code">} </code>

        <code class="indent-code code-space">if user_input == "new york" </code>
        <code class="indent-code block-indent">  puts tri_state_abbr["new york"] </code>
        <code class="indent-code">elsif user_input == "new jersey" </code>
        <code class="indent-code block-indent">  puts tri_state_abbr["new jersey"] </code>
        <code class="indent-code">else </code>
        <code class="indent-code block-indent">  puts tri_stat_abbr["connecticut"] </code>
        <code class="indent-code">end </code>
      <p>
        OK, I get it. That was a bunch of random Ruby code you may not be familiar with. All told, we are first asking a user for the name of a state, they input their response, which get saved to the variable <code>user_input</code> then, based on the hash we created, we use an <code>if</code> statement to figure out what the user's input was and, based on that input, we call the appropriate value from the hash using that value's key. Now, using a hash is really helpful in this situation. With hash key/value pairs, we can best approximate the exact input from the user. At no point would we ask the user to input a number and then use that number as an index to call on an array. It's much easier to ask the user for English words and then use that exact input as a key name to call a value in a hash. This idea stems from the inherent customization properties of the key/value pair in a hash. With an array, the index number is the index number; in other words, you can't change the name/number of the indexes in an array. Index 0 is always index 0 and so on and so forth. In a hash, however, we have the ability to create the names of each key as well as the substance of the associated value. Hashes give us an endless possibility for key names, which can really help us create an organization system for values that fits seamlessly with the goals of our program, like the one we wrote above.
      </p>
      <p>
        If I can make the quickest of asides right at the end, without diving into too much detail, hashes are also different from arrays (and possibly better) because the keys in a hash can be written as Ruby symbols. This is an interesting point to mention for a few reasons. Symbols are different than other objects in Ruby in that they are unique, in Ruby terms. That means that if you create a symbol, that symbol will always have the same id, which is not the case for other Ruby objects. Symbols are also immutable, meaning you can't append anything to the symbol once it is created. What does this mean for arrays versus hashes? Well, symbols may not be a big advantage for hashes, but using sybmols as keys allow Ruby to process accessibility of a value faster and ensures that the keys for a hash can never be changed, unlike  string. Symbols as keys are just another feature of hashes that add to its general customization abilities, which is a big advantage over arrays.

      </p>
    </section>

    <section class="text-over">
        <h3 class="strong">Conclusion</h3>
        <p>
          So, arrays and hashes. Both are Ruby objects. Both contain lists of values. One is a little more strict in accessibility than the other, but, regardless, both are efficient and powerful ways of consolidating information and accessing that information for use in a Ruby program.
        </p>
      </section>
    </article>
  </main>

 <footer class="container">
  <p class="links">
    <a href="https://github.com/jmcolella"><img class="icon" src="../imgs/github.png" alt="Github"></a>
    <a href="https://www.linkedin.com/in/john-colella-61597775"><img class="icon" src="../imgs/linkedin.png" alt="Linkedin"></a>
    <a href="https://www.facebook.com/john.colella.9"><img class="icon" src="../imgs/facebook.png" alt="Facebook"></a>
    <a href="mailto:colella.john@gmail.com"><img class="icon" src="../imgs/email.png" alt="E-Mail"></a>
  </p>
 </footer>

</body>
</html>