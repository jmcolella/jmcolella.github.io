<!DOCTYPE html>
<head>
  <title>John Colella | Blog Post </title>
  <meta charset="UTF-8" name="viewport" content="width=device-width"/>
  <link href='https://fonts.googleapis.com/css?family=Ubuntu%7COxygen:400,700' rel='stylesheet' type='text/css'>
  <!-- <link type="text/css" rel="stylesheet" href="../stylesheets/default.css"> -->
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-post-template.css">
</head>

<body>

 <header class="head-container">
     <nav>
      <h1><a href="../index.html">John Colella</a></h1>
      <ul class="head-links">
        <li><a href="../index.html">Home</a></li>
        <li><a href="../index.html#about">About</a></li>
        <li><a href="..index.html#projects">Projects</a></li>
        <li><a href="../blog/index.html">Blog</a></li>
        <li><a href="../index.html#contact">Contact</a></li>
      </ul>
    </nav>
 </header>

 <nav class="post-nav font">
  <ul>
    <li><a href="arrays-hashes.html">Previous Post</a> | <a href = "ruby-classes.html"> Next Post</a></li>
  </ul>
 </nav>

 <main>

    <section class="header font">
      <h2>DBC | Week 5 Post</h2>
      <h3>In which I discuss the Ruby Enumerable method <code>each_slice</code></h3>
      <h4>March 13, 2016</h4>
     </section>

    <section id="line">
    </section>

  <article class="font">
    <section class="text-over">
      <h3 class="strong">Introduction</h3>
      <p>
        Welcome to the fourth post on my Dev Bootcamp blog! Things are getting a bit more intense with Ruby, and after having covered Arrays and Hashes last week, we'll be diving into some more complex concepts.
      </p>
      <p>
        This week, I'm going to take a look at <code>Enumerable</code> in Ruby, with a particular focus on the <code>Enumerable</code> method <code>each_slice</code>. As you'll see, <code>Enumerable</code> gives us a lot of firepower when working with objects in Ruby. Let's dive in...
      </p>
    </section>

    <section class="text-over">
      <h3 class="strong">Enumerable module</h3>
      <p>
        Before we get into any specifics, we need to look first at <code>Enumerable</code>. <code>Enumerable</code> is a module in Ruby that gives a class Object certain abilities, all of which stem from the method <code>each</code>. As a quick aside, a Ruby module is the parent object of a Ruby class, and it contains a bundle of methods and constants, but not instance methods (which classes do contain). So, <code>Enumerable</code>, as a module, has a bunch of methods and constants that can be given to a <code>Class</code> object that has an <code>each</code> method which yields items to a code block. Without this <code>each</code>, all of the methods contained within <code>Enumerable</code> don't have anything to build off of. In other words, <code>each</code> is like the foundation for any <code>Enumerable</code> method; without the foundation, it's impossible to use anything else related to that foundation.
      </p>
      <p>
        So, what exactly does this look like? Let's create a class called <code>Pizza</code> that has an each method that yields the toppings of a pizza:
      </p>
       <code class="indent-code">class Pizza</code>
       <code class="indent-code-level-1">include Enumerable</code>
       <code class="indent-code-level-1">def each</code>
       <code class="indent-code-level-2">yield "Dough"</code>
       <code class="indent-code-level-2">yield "Tomato Sauce"</code>
       <code class="indent-code-level-2">yield "Mozzarella Cheese"</code>
       <code class="indent-code-level-1">end</code>
       <code class="indent-code">end</code>
      <p>
        So, in the above coe snippet, we defined a class <code>Pizza</code>, and within that class, we told it to include <code>Enumerable</code>, so that we can have use all of its methods, and then we defined an <code>each</code> method, which yields a bunch of pizza ingredients and will give us access to the <code>Enumberable</code> methods. Our <code>each</code> method is pretty simply: when called on a new instance of the <code>Pizza</code> class, it simply yields to each item in the method until it reaches the end. Let's see that in action:
      </p>
      <p>
        <code class="indent-code">p = Pizza.new</code>
        <code class="indent-code">p.each do |ingredient|</code>
        <code class="indent-code-level-1">puts "Next ingredient is:</code>
        <code class="indent-code-level-1">puts #{ingredient}</code>
        <code class="indent-code">end</code>
      </p>
      <p>
        The above would produce the following:
      </p>
      <code class="indent-code">Next ingredient is: Dough</code>
      <code class="indent-code">Next ingredient is: Tomato Sauce</code>
      <code class="indent-code">Next ingredient is: Mozzarella Cheese</code>
      <p>
        So, as you can see, the <code>each</code> method yields to each item until it reaches the end of the defined method from the <code>Pizza</code> class. This is important because it sets the definition for the behavior of <code>each</code> and, therefore, dictates how the <code>Enumerable</code> methods will work in relation to the <code>Class</code> object it is included within.
      </p>
    </section>

    <section class="text-over">
      <h3 class="strong">The each_slice Method</h3>
      <p>
        OK, so we have a new class <code>Pizza</code> with a defined <code>each</code> method and it includes the <code>Enumberable</code> module. Let's make use of it and talk about one specific method in the <code>Enumerable</code> module: <code>each_slice</code>.
      </p>
      <p>
        Actually, hold up, let's back up a half step. The key thing to understand is that <code>Enumberable</code> has a slew of methods, all of which stem from <code>each</code>. The <code>each_slice</code> method is just one of them. We could also make use of methods like <code>first</code>, <code>find</code>, <code>map</code> and many others. Each one of these methods interacts with the defined <code>each</code> method in a different way and the all interact with collection objects (Arrays, Hashes, Ranges and Sets) in a different way. It's up to you to figure out the best one to use for the given task at hand.
      </p>
      <p>
        So, <code>each_slice</code>. This guy is pretty cool. When called on an object, typically an array, it "slices" up that object and returns each of those "slices" as an array. Keeping with the theme of our <code>Pizza</code> class above, let's take a look at <code>each_slice</code> in action:
      </p>
      <p>
        <code class="indent-code">supreme = Pizza.new</code>
        <code class="indent-code">supreme = ["sasauge", "broccoli", "mushrooms", "olives", "pepperoni", "peppers"]</code>
        <code class="indent-code">supreme.each_slice(2) {|ingredients| p ingredients}</code>
        <code class="indent-code">["sasauge", "broccoli"]</code>
        <code class="indent-code">["mushrooms", "olives"]</code>
        <code class="indent-code">["pepperoni", "peppers"]</code>
        <code class="indent-code">=> nil</code>
      </p>
      <p>
        As you can see, we created an new instance of the <code>Pizza</code> class, <code>supreme</code>, and set that equal to an array of ingredients for a supreme pizza. We then called <code>each_slice</code> on that array <code>supreme</code> and got three new arrays, each with two items from the original <code>supreme</code> array. Why did we get three arrays of two? Well, as you can see, <code>each_slice</code> can take an integer as an argument, the value of which determines how many items the method will "slice" the array to which it is called. The code block following the method, to which it yields, then tells <code>each_slice</code> how to slice and what to do with it. In our case, we told <code>each_slice</code> that for each slice of ingredients (<code>|ingredients|</code>) print the ingridents to the console (<code>p ingredients</code>). This is an incredibly useful <code>Enumerable</code> method for grouping items in an array, or just breaking down an array to make it more manageable; the uses can be endless.
      </p>
      <p>
        To reiterate the point made in the section above, our use of <code>each_slice</code> in the supreme example does not work if <code>each</code> is not defined in the <code>Class</code> to which the object belongs. It is essential to have <code>each</code> in order for any <code>Enumerable</code> method to be called and used.
      </p>
    </section>

    <section class="text-over">
        <h3 class="strong">Conclusion</h3>
        <p>
          OK, was that a lot of information? I feel like that was a lot. Let's breifly break it down: <code>Enumerable</code> is a module that contains a bunch of methods and constants, all of which can be included in a <code>Class</code> object, so long as that <code>Class</code> has a defined <code>each</code> method. Without that <code>each</code> method, the <code>Enumerable</code> module and all of it's useful methods do not know how to function when called on instances of the <code>Class</code> in question. When looking at <code>each_slice</code> in relation to our <code>Pizza</code> class, we were able to call it on the instance object <code>supreme</code> becasue we defined <code>each</code> within our <code>Pizza</code> class, therefor giving us access to the wonderful world of the <code>Enumerable</code> methods. If you want more information on Enumerables and its various methods, check out David Black's "The Well-Grounded Rubyist." It's a bit heady at times, but he does a good job of delineating the <code>Enumerable</code> module and looking at it's most important/useful methods.
        </p>
      </section>
    </article>
  </main>

  <nav class="post-nav font">
   <ul>
    <li><a href = "index.html">Blog index</a></li>
   </ul>
  </nav>

</body>
</html>